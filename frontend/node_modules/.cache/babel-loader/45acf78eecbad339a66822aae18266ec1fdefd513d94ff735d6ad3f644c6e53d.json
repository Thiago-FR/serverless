{"ast":null,"code":"import uniq from 'lodash/uniq';\nimport uniqBy from 'lodash/uniqBy';\nimport sortBy from 'lodash/sortBy';\nimport last from 'lodash/last';\nimport isDate from 'lodash/isDate';\nimport { utcParse, timeParse } from 'd3-time-format';\nimport { scaleLinear, scalePoint, scaleBand, scaleUtc, scaleTime, scaleLog, scaleSymlog } from 'd3-scale';\nimport { timeInterval, timeMillisecond, utcMillisecond, timeSecond, utcSecond, timeMinute, utcMinute, timeHour, utcHour, timeWeek, utcWeek, timeSunday, utcSunday, timeMonday, utcMonday, timeTuesday, utcTuesday, timeWednesday, utcWednesday, timeThursday, utcThursday, timeFriday, utcFriday, timeSaturday, utcSaturday, timeMonth, utcMonth, timeYear, utcYear } from 'd3-time';\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n  return arr2;\n}\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter);\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread2(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n  return target;\n}\nvar timePrecisions = ['millisecond', 'second', 'minute', 'hour', 'day', 'month', 'year'];\nvar precisionCutOffs = [function (date) {\n  return date.setMilliseconds(0);\n}, function (date) {\n  return date.setSeconds(0);\n}, function (date) {\n  return date.setMinutes(0);\n}, function (date) {\n  return date.setHours(0);\n}, function (date) {\n  return date.setDate(1);\n}, function (date) {\n  return date.setMonth(0);\n}];\nvar precisionCutOffsByType = {\n  millisecond: [],\n  second: precisionCutOffs.slice(0, 1),\n  minute: precisionCutOffs.slice(0, 2),\n  hour: precisionCutOffs.slice(0, 3),\n  day: precisionCutOffs.slice(0, 4),\n  month: precisionCutOffs.slice(0, 5),\n  year: precisionCutOffs.slice(0, 6)\n};\nvar createPrecisionMethod = function createPrecisionMethod(precision) {\n  return function (date) {\n    precisionCutOffsByType[precision].forEach(function (cutOff) {\n      cutOff(date);\n    });\n    return date;\n  };\n};\nvar createDateNormalizer = function createDateNormalizer(_ref) {\n  var _ref$format = _ref.format,\n    format = _ref$format === void 0 ? 'native' : _ref$format,\n    _ref$precision = _ref.precision,\n    precision = _ref$precision === void 0 ? 'millisecond' : _ref$precision,\n    _ref$useUTC = _ref.useUTC,\n    useUTC = _ref$useUTC === void 0 ? true : _ref$useUTC;\n  var precisionFn = createPrecisionMethod(precision);\n  return function (value) {\n    if (value === undefined) {\n      return value;\n    }\n    if (format === 'native' || value instanceof Date) {\n      return precisionFn(value);\n    }\n    var parseTime = useUTC ? utcParse(format) : timeParse(format);\n    return precisionFn(parseTime(value));\n  };\n};\nvar createLinearScale = function createLinearScale(_ref, data, size, axis) {\n  var _ref$min = _ref.min,\n    min = _ref$min === void 0 ? 0 : _ref$min,\n    _ref$max = _ref.max,\n    max = _ref$max === void 0 ? 'auto' : _ref$max,\n    _ref$stacked = _ref.stacked,\n    stacked = _ref$stacked === void 0 ? false : _ref$stacked,\n    _ref$reverse = _ref.reverse,\n    reverse = _ref$reverse === void 0 ? false : _ref$reverse,\n    _ref$clamp = _ref.clamp,\n    clamp = _ref$clamp === void 0 ? false : _ref$clamp,\n    _ref$nice = _ref.nice,\n    nice = _ref$nice === void 0 ? false : _ref$nice;\n  var minValue;\n  if (min === 'auto') {\n    var _data$minStacked;\n    minValue = stacked === true ? (_data$minStacked = data.minStacked) !== null && _data$minStacked !== void 0 ? _data$minStacked : 0 : data.min;\n  } else {\n    minValue = min;\n  }\n  var maxValue;\n  if (max === 'auto') {\n    var _data$maxStacked;\n    maxValue = stacked === true ? (_data$maxStacked = data.maxStacked) !== null && _data$maxStacked !== void 0 ? _data$maxStacked : 0 : data.max;\n  } else {\n    maxValue = max;\n  }\n  var scale = scaleLinear().rangeRound(axis === 'x' ? [0, size] : [size, 0]).domain(reverse ? [maxValue, minValue] : [minValue, maxValue]).clamp(clamp);\n  if (nice === true) scale.nice();else if (typeof nice === 'number') scale.nice(nice);\n  return castLinearScale(scale, stacked);\n};\nvar castLinearScale = function castLinearScale(scale) {\n  var stacked = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  var typedScale = scale;\n  typedScale.type = 'linear';\n  typedScale.stacked = stacked;\n  return typedScale;\n};\nvar createPointScale = function createPointScale(_spec, data, size) {\n  var scale = scalePoint().range([0, size]).domain(data.all);\n  var typedScale = scale;\n  typedScale.type = 'point';\n  return typedScale;\n};\nvar createBandScale = function createBandScale(_ref, data, size, axis) {\n  var _ref$round = _ref.round,\n    round = _ref$round === void 0 ? true : _ref$round;\n  var scale = scaleBand().range(axis === 'x' ? [0, size] : [size, 0]).domain(data.all).round(round);\n  return castBandScale(scale);\n};\nvar castBandScale = function castBandScale(scale) {\n  var typedScale = scale;\n  typedScale.type = 'band';\n  return typedScale;\n};\nvar createTimeScale = function createTimeScale(_ref, data, size) {\n  var _ref$format = _ref.format,\n    format = _ref$format === void 0 ? 'native' : _ref$format,\n    _ref$precision = _ref.precision,\n    precision = _ref$precision === void 0 ? 'millisecond' : _ref$precision,\n    _ref$min = _ref.min,\n    min = _ref$min === void 0 ? 'auto' : _ref$min,\n    _ref$max = _ref.max,\n    max = _ref$max === void 0 ? 'auto' : _ref$max,\n    _ref$useUTC = _ref.useUTC,\n    useUTC = _ref$useUTC === void 0 ? true : _ref$useUTC,\n    _ref$nice = _ref.nice,\n    nice = _ref$nice === void 0 ? false : _ref$nice;\n  var normalize = createDateNormalizer({\n    format: format,\n    precision: precision,\n    useUTC: useUTC\n  });\n  var minValue;\n  if (min === 'auto') {\n    minValue = normalize(data.min);\n  } else if (format !== 'native') {\n    minValue = normalize(min);\n  } else {\n    minValue = min;\n  }\n  var maxValue;\n  if (max === 'auto') {\n    maxValue = normalize(data.max);\n  } else if (format !== 'native') {\n    maxValue = normalize(max);\n  } else {\n    maxValue = max;\n  }\n  var scale = useUTC ? scaleUtc() : scaleTime();\n  scale.range([0, size]);\n  if (minValue && maxValue) scale.domain([minValue, maxValue]);\n  if (nice === true) scale.nice();else if (typeof nice === 'object' || typeof nice === 'number') scale.nice(nice);\n  var typedScale = scale;\n  typedScale.type = 'time';\n  typedScale.useUTC = useUTC;\n  return typedScale;\n};\nvar createLogScale = function createLogScale(_ref, data, size, axis) {\n  var _ref$base = _ref.base,\n    base = _ref$base === void 0 ? 10 : _ref$base,\n    _ref$min = _ref.min,\n    min = _ref$min === void 0 ? 'auto' : _ref$min,\n    _ref$max = _ref.max,\n    max = _ref$max === void 0 ? 'auto' : _ref$max;\n  var hasZero = data.all.some(function (v) {\n    return v === 0;\n  });\n  if (hasZero) {\n    throw new Error(\"a log scale domain must not include or cross zero\");\n  }\n  var sign;\n  var hasMixedSign = false;\n  data.all.filter(function (v) {\n    return v != null;\n  }).forEach(function (v) {\n    if (hasMixedSign) return;\n    if (sign === undefined) {\n      sign = Math.sign(v);\n    } else if (Math.sign(v) !== sign) {\n      hasMixedSign = true;\n    }\n  });\n  if (hasMixedSign) {\n    throw new Error(\"a log scale domain must be strictly-positive or strictly-negative\");\n  }\n  var minValue;\n  if (min === 'auto') {\n    minValue = data.min;\n  } else {\n    minValue = min;\n  }\n  var maxValue;\n  if (max === 'auto') {\n    maxValue = data.max;\n  } else {\n    maxValue = max;\n  }\n  var scale = scaleLog().domain([minValue, maxValue]).rangeRound(axis === 'x' ? [0, size] : [size, 0]).base(base).nice();\n  var typedScale = scale;\n  typedScale.type = 'log';\n  return scale;\n};\nvar createSymlogScale = function createSymlogScale(_ref, data, size, axis) {\n  var _ref$constant = _ref.constant,\n    constant = _ref$constant === void 0 ? 1 : _ref$constant,\n    _ref$min = _ref.min,\n    min = _ref$min === void 0 ? 'auto' : _ref$min,\n    _ref$max = _ref.max,\n    max = _ref$max === void 0 ? 'auto' : _ref$max,\n    _ref$reverse = _ref.reverse,\n    reverse = _ref$reverse === void 0 ? false : _ref$reverse;\n  var minValue;\n  if (min === 'auto') {\n    minValue = data.min;\n  } else {\n    minValue = min;\n  }\n  var maxValue;\n  if (max === 'auto') {\n    maxValue = data.max;\n  } else {\n    maxValue = max;\n  }\n  var scale = scaleSymlog().constant(constant).rangeRound(axis === 'x' ? [0, size] : [size, 0]).nice();\n  if (reverse === true) scale.domain([maxValue, minValue]);else scale.domain([minValue, maxValue]);\n  var typedScale = scale;\n  typedScale.type = 'symlog';\n  return typedScale;\n};\nvar getOtherAxis = function getOtherAxis(axis) {\n  return axis === 'x' ? 'y' : 'x';\n};\nvar compareValues = function compareValues(a, b) {\n  return a === b;\n};\nvar compareDateValues = function compareDateValues(a, b) {\n  return a.getTime() === b.getTime();\n};\nfunction computeScale(spec, data, size, axis) {\n  switch (spec.type) {\n    case 'linear':\n      return createLinearScale(spec, data, size, axis);\n    case 'point':\n      return createPointScale(spec, data, size);\n    case 'band':\n      return createBandScale(spec, data, size, axis);\n    case 'time':\n      return createTimeScale(spec, data, size);\n    case 'log':\n      return createLogScale(spec, data, size, axis);\n    case 'symlog':\n      return createSymlogScale(spec, data, size, axis);\n    default:\n      throw new Error('invalid scale spec');\n  }\n}\nvar nestSerieData = function nestSerieData(serie) {\n  return _objectSpread2(_objectSpread2({}, serie), {}, {\n    data: serie.data.map(function (d) {\n      return {\n        data: _objectSpread2({}, d)\n      };\n    })\n  });\n};\nvar getDatumAxisPosition = function getDatumAxisPosition(datum, axis, scale) {\n  var _scale;\n  if ('stacked' in scale && scale.stacked) {\n    var stackedValue = datum.data[axis === 'x' ? 'xStacked' : 'yStacked'];\n    if (stackedValue === null || stackedValue === undefined) {\n      return null;\n    }\n    return scale(stackedValue);\n  }\n  return (_scale = scale(datum.data[axis])) !== null && _scale !== void 0 ? _scale : null;\n};\nvar computeXYScalesForSeries = function computeXYScalesForSeries(series, xScaleSpec, yScaleSpec, width, height) {\n  var nestedSeries = series.map(function (serie) {\n    return nestSerieData(serie);\n  });\n  var xy = generateSeriesXY(nestedSeries, xScaleSpec, yScaleSpec);\n  if ('stacked' in xScaleSpec && xScaleSpec.stacked === true) {\n    stackX(xy, nestedSeries);\n  }\n  if ('stacked' in yScaleSpec && yScaleSpec.stacked === true) {\n    stackY(xy, nestedSeries);\n  }\n  var xScale = computeScale(xScaleSpec, xy.x, width, 'x');\n  var yScale = computeScale(yScaleSpec, xy.y, height, 'y');\n  var computedSeries = nestedSeries.map(function (serie) {\n    return _objectSpread2(_objectSpread2({}, serie), {}, {\n      data: serie.data.map(function (datum) {\n        return _objectSpread2(_objectSpread2({}, datum), {}, {\n          position: {\n            x: getDatumAxisPosition(datum, 'x', xScale),\n            y: getDatumAxisPosition(datum, 'y', yScale)\n          }\n        });\n      })\n    });\n  });\n  return _objectSpread2(_objectSpread2({}, xy), {}, {\n    series: computedSeries,\n    xScale: xScale,\n    yScale: yScale\n  });\n};\nvar generateSeriesXY = function generateSeriesXY(series, xScaleSpec, yScaleSpec) {\n  return {\n    x: generateSeriesAxis(series, 'x', xScaleSpec),\n    y: generateSeriesAxis(series, 'y', yScaleSpec)\n  };\n};\nvar generateSeriesAxis = function generateSeriesAxis(series, axis, scaleSpec) {\n  var _ref = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {},\n    _ref$getValue = _ref.getValue,\n    getValue = _ref$getValue === void 0 ? function (d) {\n      return d.data[axis];\n    } : _ref$getValue,\n    _ref$setValue = _ref.setValue,\n    setValue = _ref$setValue === void 0 ? function (d, v) {\n      d.data[axis] = v;\n    } : _ref$setValue;\n  if (scaleSpec.type === 'linear') {\n    series.forEach(function (serie) {\n      serie.data.forEach(function (d) {\n        var value = getValue(d);\n        if (value) {\n          setValue(d, parseFloat(String(value)));\n        }\n      });\n    });\n  } else if (scaleSpec.type === 'time' && scaleSpec.format !== 'native') {\n    var parseTime = createDateNormalizer(scaleSpec);\n    series.forEach(function (serie) {\n      serie.data.forEach(function (d) {\n        var value = getValue(d);\n        if (value) {\n          setValue(d, parseTime(value));\n        }\n      });\n    });\n  }\n  var values = [];\n  series.forEach(function (serie) {\n    serie.data.forEach(function (d) {\n      values.push(getValue(d));\n    });\n  });\n  switch (scaleSpec.type) {\n    case 'linear':\n      {\n        var all = sortBy(uniq(values).filter(function (v) {\n          return v !== null;\n        }), function (v) {\n          return v;\n        });\n        return {\n          all: all,\n          min: Math.min.apply(Math, _toConsumableArray(all)),\n          max: Math.max.apply(Math, _toConsumableArray(all))\n        };\n      }\n    case 'time':\n      {\n        var _all = uniqBy(values, function (v) {\n          return v.getTime();\n        }).slice(0).sort(function (a, b) {\n          return b.getTime() - a.getTime();\n        }).reverse();\n        return {\n          all: _all,\n          min: _all[0],\n          max: last(_all)\n        };\n      }\n    default:\n      {\n        var _all2 = uniq(values);\n        return {\n          all: _all2,\n          min: _all2[0],\n          max: last(_all2)\n        };\n      }\n  }\n};\nvar stackAxis = function stackAxis(axis, xy, series) {\n  var otherAxis = getOtherAxis(axis);\n  var all = [];\n  xy[otherAxis].all.forEach(function (v) {\n    var compare = isDate(v) ? compareDateValues : compareValues;\n    var stack = [];\n    series.forEach(function (serie) {\n      var datum = serie.data.find(function (d) {\n        return compare(d.data[otherAxis], v);\n      });\n      var value = null;\n      var stackValue = null;\n      if (datum !== undefined) {\n        value = datum.data[axis];\n        if (value !== null) {\n          var head = last(stack);\n          if (head === undefined) {\n            stackValue = value;\n          } else if (head !== null) {\n            stackValue = head + value;\n          }\n        }\n        datum.data[axis === 'x' ? 'xStacked' : 'yStacked'] = stackValue;\n      }\n      stack.push(stackValue);\n      if (stackValue !== null) {\n        all.push(stackValue);\n      }\n    });\n  });\n  xy[axis].minStacked = Math.min.apply(Math, all);\n  xy[axis].maxStacked = Math.max.apply(Math, all);\n};\nvar stackX = function stackX(xy, series) {\n  return stackAxis('x', xy, series);\n};\nvar stackY = function stackY(xy, series) {\n  return stackAxis('y', xy, series);\n};\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\nfunction _iterableToArrayLimit(arr, i) {\n  if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n  return _arr;\n}\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\nvar centerScale = function centerScale(scale) {\n  var bandwidth = scale.bandwidth();\n  if (bandwidth === 0) return scale;\n  var offset = bandwidth / 2;\n  if (scale.round()) {\n    offset = Math.round(offset);\n  }\n  return function (d) {\n    var _scale;\n    return ((_scale = scale(d)) !== null && _scale !== void 0 ? _scale : 0) + offset;\n  };\n};\nvar timeDay = timeInterval(function (date) {\n  return date.setHours(0, 0, 0, 0);\n}, function (date, step) {\n  return date.setDate(date.getDate() + step);\n}, function (start, end) {\n  return (end.getTime() - start.getTime()) / 864e5;\n}, function (date) {\n  return Math.floor(date.getTime() / 864e5);\n});\nvar utcDay = timeInterval(function (date) {\n  return date.setUTCHours(0, 0, 0, 0);\n}, function (date, step) {\n  return date.setUTCDate(date.getUTCDate() + step);\n}, function (start, end) {\n  return (end.getTime() - start.getTime()) / 864e5;\n}, function (date) {\n  return Math.floor(date.getTime() / 864e5);\n});\nvar timeByType = {\n  millisecond: [timeMillisecond, utcMillisecond],\n  second: [timeSecond, utcSecond],\n  minute: [timeMinute, utcMinute],\n  hour: [timeHour, utcHour],\n  day: [timeDay, utcDay],\n  week: [timeWeek, utcWeek],\n  sunday: [timeSunday, utcSunday],\n  monday: [timeMonday, utcMonday],\n  tuesday: [timeTuesday, utcTuesday],\n  wednesday: [timeWednesday, utcWednesday],\n  thursday: [timeThursday, utcThursday],\n  friday: [timeFriday, utcFriday],\n  saturday: [timeSaturday, utcSaturday],\n  month: [timeMonth, utcMonth],\n  year: [timeYear, utcYear]\n};\nvar timeTypes = Object.keys(timeByType);\nvar timeIntervalRegexp = new RegExp(\"^every\\\\s*(\\\\d+)?\\\\s*(\".concat(timeTypes.join('|'), \")s?$\"), 'i');\nvar isInteger = function isInteger(value) {\n  return typeof value === 'number' && isFinite(value) && Math.floor(value) === value;\n};\nvar getScaleTicks = function getScaleTicks(scale, spec) {\n  if (Array.isArray(spec)) {\n    return spec;\n  }\n  if (typeof spec === 'string' && 'useUTC' in scale) {\n    var matches = spec.match(timeIntervalRegexp);\n    if (matches) {\n      var _matches = _slicedToArray(matches, 3),\n        amount = _matches[1],\n        type = _matches[2];\n      var timeType = timeByType[type][scale.useUTC ? 1 : 0];\n      if (type === 'day') {\n        var _timeType$every$range, _timeType$every;\n        var _scale$domain = scale.domain(),\n          _scale$domain2 = _slicedToArray(_scale$domain, 2),\n          start = _scale$domain2[0],\n          originalStop = _scale$domain2[1];\n        var stop = new Date(originalStop);\n        stop.setDate(stop.getDate() + 1);\n        return (_timeType$every$range = (_timeType$every = timeType.every(Number(amount !== null && amount !== void 0 ? amount : 1))) === null || _timeType$every === void 0 ? void 0 : _timeType$every.range(start, stop)) !== null && _timeType$every$range !== void 0 ? _timeType$every$range : [];\n      }\n      if (amount === undefined) {\n        return scale.ticks(timeType);\n      }\n      var interval = timeType.every(Number(amount));\n      if (interval) {\n        return scale.ticks(interval);\n      }\n    }\n    throw new Error(\"Invalid tickValues: \".concat(spec));\n  }\n  if ('ticks' in scale) {\n    if (spec === undefined) {\n      return scale.ticks();\n    }\n    if (isInteger(spec)) {\n      return scale.ticks(spec);\n    }\n  }\n  return scale.domain();\n};\nexport { castBandScale, castLinearScale, centerScale, compareDateValues, compareValues, computeScale, computeXYScalesForSeries, createBandScale, createDateNormalizer, createLinearScale, createLogScale, createPointScale, createPrecisionMethod, createSymlogScale, createTimeScale, generateSeriesAxis, generateSeriesXY, getOtherAxis, getScaleTicks, precisionCutOffs, precisionCutOffsByType, stackAxis, timePrecisions };","map":{"version":3,"names":["_arrayLikeToArray","arr","len","length","i","arr2","Array","_arrayWithoutHoles","isArray","_iterableToArray","iter","Symbol","iterator","Object","from","_unsupportedIterableToArray","o","minLen","n","prototype","toString","call","slice","constructor","name","test","_nonIterableSpread","TypeError","_toConsumableArray","_defineProperty","obj","key","value","defineProperty","enumerable","configurable","writable","ownKeys","object","enumerableOnly","keys","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","push","apply","_objectSpread2","target","arguments","source","forEach","getOwnPropertyDescriptors","defineProperties","timePrecisions","precisionCutOffs","date","setMilliseconds","setSeconds","setMinutes","setHours","setDate","setMonth","precisionCutOffsByType","millisecond","second","minute","hour","day","month","year","createPrecisionMethod","precision","cutOff","createDateNormalizer","_ref","_ref$format","format","_ref$precision","_ref$useUTC","useUTC","precisionFn","undefined","Date","parseTime","utcParse","timeParse","createLinearScale","data","size","axis","_ref$min","min","_ref$max","max","_ref$stacked","stacked","_ref$reverse","reverse","_ref$clamp","clamp","_ref$nice","nice","minValue","_data$minStacked","minStacked","maxValue","_data$maxStacked","maxStacked","scale","scaleLinear","rangeRound","domain","castLinearScale","typedScale","type","createPointScale","_spec","scalePoint","range","all","createBandScale","_ref$round","round","scaleBand","castBandScale","createTimeScale","normalize","scaleUtc","scaleTime","createLogScale","_ref$base","base","hasZero","some","v","Error","sign","hasMixedSign","Math","scaleLog","createSymlogScale","_ref$constant","constant","scaleSymlog","getOtherAxis","compareValues","a","b","compareDateValues","getTime","computeScale","spec","nestSerieData","serie","map","d","getDatumAxisPosition","datum","_scale","stackedValue","computeXYScalesForSeries","series","xScaleSpec","yScaleSpec","width","height","nestedSeries","xy","generateSeriesXY","stackX","stackY","xScale","x","yScale","y","computedSeries","position","generateSeriesAxis","scaleSpec","_ref$getValue","getValue","_ref$setValue","setValue","parseFloat","String","values","sortBy","uniq","_all","uniqBy","sort","last","_all2","stackAxis","otherAxis","compare","isDate","stack","find","stackValue","head","_arrayWithHoles","_iterableToArrayLimit","_arr","_n","_d","_e","_i","_s","next","done","err","_nonIterableRest","_slicedToArray","centerScale","bandwidth","offset","timeDay","timeInterval","step","getDate","start","end","floor","utcDay","setUTCHours","setUTCDate","getUTCDate","timeByType","timeMillisecond","utcMillisecond","timeSecond","utcSecond","timeMinute","utcMinute","timeHour","utcHour","week","timeWeek","utcWeek","sunday","timeSunday","utcSunday","monday","timeMonday","utcMonday","tuesday","timeTuesday","utcTuesday","wednesday","timeWednesday","utcWednesday","thursday","timeThursday","utcThursday","friday","timeFriday","utcFriday","saturday","timeSaturday","utcSaturday","timeMonth","utcMonth","timeYear","utcYear","timeTypes","timeIntervalRegexp","RegExp","concat","join","isInteger","isFinite","getScaleTicks","matches","match","_matches","amount","timeType","_timeType$every$range","_timeType$every","_scale$domain","_scale$domain2","originalStop","stop","every","Number","ticks","interval"],"sources":["/home/thiago/Documentos/Testes/KPIs/frontend/node_modules/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js","/home/thiago/Documentos/Testes/KPIs/frontend/node_modules/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/arrayWithoutHoles.js","/home/thiago/Documentos/Testes/KPIs/frontend/node_modules/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/iterableToArray.js","/home/thiago/Documentos/Testes/KPIs/frontend/node_modules/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js","/home/thiago/Documentos/Testes/KPIs/frontend/node_modules/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/nonIterableSpread.js","/home/thiago/Documentos/Testes/KPIs/frontend/node_modules/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js","/home/thiago/Documentos/Testes/KPIs/frontend/node_modules/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/defineProperty.js","/home/thiago/Documentos/Testes/KPIs/frontend/node_modules/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread2.js","/home/thiago/Documentos/Testes/KPIs/frontend/node_modules/@nivo/scales/src/timeHelpers.ts","/home/thiago/Documentos/Testes/KPIs/frontend/node_modules/@nivo/scales/src/linearScale.ts","/home/thiago/Documentos/Testes/KPIs/frontend/node_modules/@nivo/scales/src/pointScale.ts","/home/thiago/Documentos/Testes/KPIs/frontend/node_modules/@nivo/scales/src/bandScale.ts","/home/thiago/Documentos/Testes/KPIs/frontend/node_modules/@nivo/scales/src/timeScale.ts","/home/thiago/Documentos/Testes/KPIs/frontend/node_modules/@nivo/scales/src/logScale.ts","/home/thiago/Documentos/Testes/KPIs/frontend/node_modules/@nivo/scales/src/symlogScale.ts","/home/thiago/Documentos/Testes/KPIs/frontend/node_modules/@nivo/scales/src/compute.ts","/home/thiago/Documentos/Testes/KPIs/frontend/node_modules/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/arrayWithHoles.js","/home/thiago/Documentos/Testes/KPIs/frontend/node_modules/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/iterableToArrayLimit.js","/home/thiago/Documentos/Testes/KPIs/frontend/node_modules/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/nonIterableRest.js","/home/thiago/Documentos/Testes/KPIs/frontend/node_modules/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray.js","/home/thiago/Documentos/Testes/KPIs/frontend/node_modules/@nivo/scales/src/ticks.ts"],"sourcesContent":["export default function _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}","import arrayLikeToArray from \"@babel/runtime/helpers/esm/arrayLikeToArray\";\nexport default function _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return arrayLikeToArray(arr);\n}","export default function _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter);\n}","import arrayLikeToArray from \"@babel/runtime/helpers/esm/arrayLikeToArray\";\nexport default function _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return arrayLikeToArray(o, minLen);\n}","export default function _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}","import arrayWithoutHoles from \"@babel/runtime/helpers/esm/arrayWithoutHoles\";\nimport iterableToArray from \"@babel/runtime/helpers/esm/iterableToArray\";\nimport unsupportedIterableToArray from \"@babel/runtime/helpers/esm/unsupportedIterableToArray\";\nimport nonIterableSpread from \"@babel/runtime/helpers/esm/nonIterableSpread\";\nexport default function _toConsumableArray(arr) {\n  return arrayWithoutHoles(arr) || iterableToArray(arr) || unsupportedIterableToArray(arr) || nonIterableSpread();\n}","export default function _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}","import defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nexport default function _objectSpread2(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}","import { timeParse, utcParse } from 'd3-time-format'\n\nexport const timePrecisions = [\n    'millisecond',\n    'second',\n    'minute',\n    'hour',\n    'day',\n    'month',\n    'year',\n] as const\n\nexport type TIME_PRECISION = typeof timePrecisions[number]\n\nexport const precisionCutOffs: ((date: Date) => void)[] = [\n    date => date.setMilliseconds(0),\n    date => date.setSeconds(0),\n    date => date.setMinutes(0),\n    date => date.setHours(0),\n    date => date.setDate(1),\n    date => date.setMonth(0),\n]\n\nexport const precisionCutOffsByType: Record<TIME_PRECISION, ((date: Date) => void)[]> = {\n    millisecond: [],\n    second: precisionCutOffs.slice(0, 1),\n    minute: precisionCutOffs.slice(0, 2),\n    hour: precisionCutOffs.slice(0, 3),\n    day: precisionCutOffs.slice(0, 4),\n    month: precisionCutOffs.slice(0, 5),\n    year: precisionCutOffs.slice(0, 6),\n}\n\nexport const createPrecisionMethod = (precision: TIME_PRECISION) => (date: Date) => {\n    precisionCutOffsByType[precision].forEach(cutOff => {\n        cutOff(date)\n    })\n\n    return date\n}\n\nexport const createDateNormalizer = ({\n    format = 'native',\n    precision = 'millisecond',\n    useUTC = true,\n}: {\n    format?: 'native' | string\n    precision?: TIME_PRECISION\n    useUTC?: boolean\n}) => {\n    const precisionFn = createPrecisionMethod(precision)\n\n    return (value: Date | string | undefined) => {\n        if (value === undefined) {\n            return value\n        }\n\n        if (format === 'native' || value instanceof Date) {\n            return precisionFn(value as Date)\n        }\n\n        const parseTime = useUTC ? utcParse(format) : timeParse(format)\n        return precisionFn(parseTime(value as string) as Date)\n    }\n}\n","import { NumberValue, scaleLinear, ScaleLinear as D3ScaleLinear } from 'd3-scale'\nimport { ScaleLinearSpec, ScaleLinear, ComputedSerieAxis, ScaleAxis } from './types'\n\nexport const createLinearScale = <Output extends NumberValue>(\n    {\n        min = 0,\n        max = 'auto',\n        stacked = false,\n        reverse = false,\n        clamp = false,\n        nice = false,\n    }: ScaleLinearSpec,\n    data: ComputedSerieAxis<Output>,\n    size: number,\n    axis: ScaleAxis\n) => {\n    let minValue: NumberValue\n    if (min === 'auto') {\n        minValue = stacked === true ? data.minStacked ?? 0 : data.min\n    } else {\n        minValue = min\n    }\n\n    let maxValue: NumberValue\n    if (max === 'auto') {\n        maxValue = stacked === true ? data.maxStacked ?? 0 : data.max\n    } else {\n        maxValue = max\n    }\n\n    const scale = scaleLinear<number, Output>()\n        .rangeRound(axis === 'x' ? [0, size] : [size, 0])\n        .domain(reverse ? [maxValue, minValue] : [minValue, maxValue])\n        .clamp(clamp)\n\n    if (nice === true) scale.nice()\n    else if (typeof nice === 'number') scale.nice(nice)\n\n    return castLinearScale<number, Output>(scale, stacked)\n}\n\nexport const castLinearScale = <Range, Output>(\n    scale: D3ScaleLinear<Range, Output>,\n    stacked = false\n) => {\n    const typedScale = (scale as unknown) as ScaleLinear<number>\n    typedScale.type = 'linear'\n    typedScale.stacked = stacked\n\n    return typedScale\n}\n","import { scalePoint } from 'd3-scale'\nimport { ComputedSerieAxis, ScalePoint, ScalePointSpec, StringValue } from './types'\n\nexport const createPointScale = <Input extends StringValue>(\n    _spec: ScalePointSpec,\n    data: ComputedSerieAxis<Input>,\n    size: number\n) => {\n    const scale = scalePoint<Input>().range([0, size]).domain(data.all)\n\n    const typedScale = scale as ScalePoint<Input>\n    typedScale.type = 'point'\n\n    return typedScale\n}\n","import { scaleBand, ScaleBand as D3ScaleBand } from 'd3-scale'\nimport { ComputedSerieAxis, ScaleBand, ScaleBandSpec, StringValue, ScaleAxis } from './types'\n\nexport const createBandScale = <Input extends StringValue>(\n    { round = true }: ScaleBandSpec,\n    data: ComputedSerieAxis<Input>,\n    size: number,\n    axis: ScaleAxis\n) => {\n    const scale = scaleBand<Input>()\n        .range(axis === 'x' ? [0, size] : [size, 0])\n        .domain(data.all)\n        .round(round)\n\n    return castBandScale<Input>(scale)\n}\n\nexport const castBandScale = <Input>(scale: D3ScaleBand<Input>) => {\n    const typedScale = scale as ScaleBand<Input>\n    typedScale.type = 'band'\n\n    return typedScale\n}\n","import { NumberValue, scaleTime, scaleUtc } from 'd3-scale'\nimport { createDateNormalizer } from './timeHelpers'\nimport { ComputedSerieAxis, ScaleTime, ScaleTimeSpec } from './types'\n\nexport const createTimeScale = <Input extends Date | NumberValue>(\n    {\n        format = 'native',\n        precision = 'millisecond',\n        min = 'auto',\n        max = 'auto',\n        useUTC = true,\n        nice = false,\n    }: ScaleTimeSpec,\n    data: ComputedSerieAxis<string | Date>,\n    size: number\n) => {\n    const normalize = createDateNormalizer({ format, precision, useUTC })\n\n    let minValue: Date | undefined\n    if (min === 'auto') {\n        minValue = normalize(data.min)\n    } else if (format !== 'native') {\n        minValue = normalize(min)\n    } else {\n        minValue = min as Date\n    }\n\n    let maxValue: Date | undefined\n    if (max === 'auto') {\n        maxValue = normalize(data.max)\n    } else if (format !== 'native') {\n        maxValue = normalize(max)\n    } else {\n        maxValue = max as Date\n    }\n\n    const scale = useUTC ? scaleUtc() : scaleTime()\n\n    scale.range([0, size])\n\n    if (minValue && maxValue) scale.domain([minValue, maxValue])\n\n    if (nice === true) scale.nice()\n    else if (typeof nice === 'object' || typeof nice === 'number') scale.nice(nice)\n\n    const typedScale = (scale as unknown) as ScaleTime<Input>\n\n    typedScale.type = 'time'\n    typedScale.useUTC = useUTC\n\n    return typedScale\n}\n","import { scaleLog } from 'd3-scale'\nimport { ComputedSerieAxis, ScaleAxis, ScaleLog, ScaleLogSpec } from './types'\n\nexport const createLogScale = (\n    { base = 10, min = 'auto', max = 'auto' }: ScaleLogSpec,\n    data: ComputedSerieAxis<number>,\n    size: number,\n    axis: ScaleAxis\n) => {\n    const hasZero = data.all.some(v => v === 0)\n    if (hasZero) {\n        throw new Error(`a log scale domain must not include or cross zero`)\n    }\n\n    let sign: number\n    let hasMixedSign = false\n    data.all\n        .filter(v => v != null)\n        .forEach(v => {\n            if (hasMixedSign) return\n            if (sign === undefined) {\n                sign = Math.sign(v)\n            } else if (Math.sign(v) !== sign) {\n                hasMixedSign = true\n            }\n        })\n\n    if (hasMixedSign) {\n        throw new Error(`a log scale domain must be strictly-positive or strictly-negative`)\n    }\n\n    let minValue: number\n    if (min === 'auto') {\n        minValue = data.min\n    } else {\n        minValue = min\n    }\n\n    let maxValue: number\n    if (max === 'auto') {\n        maxValue = data.max\n    } else {\n        maxValue = max\n    }\n\n    const scale = scaleLog<number, number>()\n        .domain([minValue, maxValue])\n        .rangeRound(axis === 'x' ? [0, size] : [size, 0])\n        .base(base)\n        .nice()\n\n    const typedScale = scale as ScaleLog\n    typedScale.type = 'log'\n\n    return scale\n}\n","import { scaleSymlog } from 'd3-scale'\nimport { ComputedSerieAxis, ScaleAxis, ScaleSymlog, ScaleSymlogSpec } from './types'\n\nexport const createSymlogScale = (\n    { constant = 1, min = 'auto', max = 'auto', reverse = false }: ScaleSymlogSpec,\n    data: ComputedSerieAxis<number>,\n    size: number,\n    axis: ScaleAxis\n) => {\n    let minValue: number\n    if (min === 'auto') {\n        minValue = data.min\n    } else {\n        minValue = min\n    }\n\n    let maxValue: number\n    if (max === 'auto') {\n        maxValue = data.max\n    } else {\n        maxValue = max\n    }\n\n    const scale = scaleSymlog<number, number>()\n        .constant(constant)\n        .rangeRound(axis === 'x' ? [0, size] : [size, 0])\n        .nice()\n\n    if (reverse === true) scale.domain([maxValue, minValue])\n    else scale.domain([minValue, maxValue])\n\n    const typedScale = scale as ScaleSymlog\n    typedScale.type = 'symlog'\n\n    return typedScale\n}\n","import uniq from 'lodash/uniq'\nimport uniqBy from 'lodash/uniqBy'\nimport sortBy from 'lodash/sortBy'\nimport last from 'lodash/last'\nimport isDate from 'lodash/isDate'\nimport { createDateNormalizer } from './timeHelpers'\nimport { ScaleAxis, ScaleSpec, ScaleValue, SerieAxis, ComputedSerieAxis } from './types'\nimport { createLinearScale } from './linearScale'\nimport { createPointScale } from './pointScale'\nimport { createBandScale } from './bandScale'\nimport { createTimeScale } from './timeScale'\nimport { createLogScale } from './logScale'\nimport { createSymlogScale } from './symlogScale'\n\ntype XY = ReturnType<typeof generateSeriesXY>\n\ntype StackedXY = {\n    [K in keyof XY]: XY[K] & {\n        maxStacked: number\n        minStacked: number\n    }\n}\n\ninterface SerieDatum {\n    x: number | string | Date\n    // only numbers can be stacked\n    xStacked?: number | null\n    y: number | string | Date\n    // only numbers can be stacked\n    yStacked?: number | null\n}\n\ntype Serie<S = never, D extends SerieDatum = SerieDatum> = S & {\n    data: D[]\n}\n\ntype NestedSerie<S = never, D extends SerieDatum = SerieDatum> = S & {\n    data: {\n        data: D\n    }[]\n}\n\nexport type ComputedSerie<S = never, D extends SerieDatum = SerieDatum> = S & {\n    data: {\n        data: D\n        position: {\n            x: number | null\n            y: number | null\n        }\n    }[]\n}\n\ntype Compare = <T>(a: T, b: T) => boolean\n\nexport const getOtherAxis = (axis: ScaleAxis): ScaleAxis => (axis === 'x' ? 'y' : 'x')\n\nexport const compareValues = (a: string | number, b: string | number) => a === b\nexport const compareDateValues = (a: Date, b: Date) => a.getTime() === b.getTime()\n\nexport function computeScale<Input extends ScaleValue>(\n    spec: ScaleSpec,\n    data: ComputedSerieAxis<any>,\n    size: number,\n    axis: ScaleAxis\n) {\n    switch (spec.type) {\n        case 'linear':\n            return createLinearScale(spec, data, size, axis)\n        case 'point':\n            return createPointScale<Input>(spec, data, size)\n        case 'band':\n            return createBandScale<Input>(spec, data, size, axis)\n        case 'time':\n            return createTimeScale(spec, data, size)\n        case 'log':\n            return createLogScale(spec, data, size, axis)\n        case 'symlog':\n            return createSymlogScale(spec, data, size, axis)\n        default:\n            throw new Error('invalid scale spec')\n    }\n}\n\n/**\n * Convert serie data to have the original data stored in a nested prop.\n *\n * We do this in order to avoid conflicts between raw & computed properties.\n * <- { data: { x: 1, y: 3 }[] }\n * -> { data: { data: { x: 1, y: 3 } }[] }\n */\nconst nestSerieData = <S = never, D extends SerieDatum = SerieDatum>(\n    serie: Serie<S, D>\n): NestedSerie<S, D> => ({\n    ...serie,\n    data: serie.data.map(d => ({ data: { ...d } })),\n})\n\nconst getDatumAxisPosition = <D extends SerieDatum = SerieDatum>(\n    datum: { data: D },\n    axis: ScaleAxis,\n    scale: any\n): number | null => {\n    if ('stacked' in scale && scale.stacked) {\n        const stackedValue = datum.data[axis === 'x' ? 'xStacked' : 'yStacked']\n        if (stackedValue === null || stackedValue === undefined) {\n            return null\n        }\n\n        return scale(stackedValue)\n    }\n\n    return scale(datum.data[axis]) ?? null\n}\n\n/**\n * Compute x/y d3 scales from an array of data series, and scale specifications.\n *\n * We use generics as it's not uncommon to have extra properties such as an id\n * added to the series, or extra props on data, in such case, you should override\n * the default types.\n */\nexport const computeXYScalesForSeries = <S = never, D extends SerieDatum = SerieDatum>(\n    series: Serie<S, D>[],\n    xScaleSpec: ScaleSpec,\n    yScaleSpec: ScaleSpec,\n    width: number,\n    height: number\n) => {\n    // first nest series to avoid property conflicts\n    const nestedSeries = series.map(serie => nestSerieData<S, D>(serie))\n\n    // then compute data for each axis: all, min, max values\n    const xy = generateSeriesXY<S, D>(nestedSeries, xScaleSpec, yScaleSpec)\n\n    // stack x values depending on xScale\n    if ('stacked' in xScaleSpec && xScaleSpec.stacked === true) {\n        stackX<S, D>(xy as StackedXY, nestedSeries)\n    }\n\n    // stack y values depending on yScale\n    if ('stacked' in yScaleSpec && yScaleSpec.stacked === true) {\n        stackY<S, D>(xy as StackedXY, nestedSeries)\n    }\n\n    // computes scales\n    const xScale = computeScale<D['x']>(xScaleSpec, xy.x, width, 'x')\n    const yScale = computeScale<D['y']>(yScaleSpec, xy.y, height, 'y')\n\n    // assign position to each datum in every scale\n    const computedSeries: ComputedSerie<S, D>[] = nestedSeries.map(serie => ({\n        ...serie,\n        data: serie.data.map(datum => ({\n            ...datum,\n            position: {\n                x: getDatumAxisPosition(datum, 'x', xScale),\n                y: getDatumAxisPosition(datum, 'y', yScale),\n            },\n        })),\n    }))\n\n    return {\n        ...xy,\n        series: computedSeries,\n        xScale,\n        yScale,\n    }\n}\n\nexport const generateSeriesXY = <S = never, D extends SerieDatum = SerieDatum>(\n    series: NestedSerie<S, D>[],\n    xScaleSpec: ScaleSpec,\n    yScaleSpec: ScaleSpec\n) => ({\n    x: generateSeriesAxis<'x', D['x']>(series, 'x', xScaleSpec),\n    y: generateSeriesAxis<'y', D['y']>(series, 'y', yScaleSpec),\n})\n\n/**\n * Normalize data according to scale type, (time => Date, linear => Number)\n * compute sorted unique values and min/max.\n */\nexport const generateSeriesAxis = <Axis extends ScaleAxis, Value extends ScaleValue>(\n    series: SerieAxis<Axis, Value>,\n    axis: Axis,\n    scaleSpec: ScaleSpec,\n    {\n        getValue = d => d.data[axis],\n        setValue = (d, v) => {\n            d.data[axis] = v\n        },\n    }: {\n        getValue?: (d: { data: Record<Axis, Value | null> }) => Value | null\n        setValue?: (d: { data: Record<Axis, Value | null> }, v: Value) => void\n    } = {}\n) => {\n    if (scaleSpec.type === 'linear') {\n        series.forEach(serie => {\n            serie.data.forEach(d => {\n                const value = getValue(d)\n\n                if (value) {\n                    setValue(d, (parseFloat(String(value)) as unknown) as Value)\n                }\n            })\n        })\n    } else if (scaleSpec.type === 'time' && scaleSpec.format !== 'native') {\n        // `native` means we already have Date instances,\n        // otherwise we have to convert the values to Date.\n        const parseTime = createDateNormalizer(scaleSpec)\n\n        series.forEach(serie => {\n            serie.data.forEach(d => {\n                const value = getValue(d)\n\n                if (value) {\n                    setValue(d, (parseTime(value as Date) as unknown) as Value)\n                }\n            })\n        })\n    }\n\n    const values: unknown[] = []\n\n    series.forEach(serie => {\n        serie.data.forEach(d => {\n            values.push(getValue(d))\n        })\n    })\n\n    switch (scaleSpec.type) {\n        case 'linear': {\n            const all = sortBy(\n                // filer null values to deal with holes in linechart\n                uniq(values as number[]).filter(v => v !== null),\n                v => v\n            )\n\n            return { all, min: Math.min(...all), max: Math.max(...all) }\n        }\n        case 'time': {\n            const all = uniqBy(values as Date[], v => v.getTime())\n                .slice(0)\n                .sort((a, b) => b.getTime() - a.getTime())\n                .reverse()\n\n            return { all, min: all[0], max: last(all) }\n        }\n        default: {\n            const all = uniq(values)\n\n            return { all, min: all[0], max: last(all) }\n        }\n    }\n}\n\nexport const stackAxis = <S = never, D extends SerieDatum = SerieDatum>(\n    axis: ScaleAxis,\n    xy: StackedXY,\n    series: NestedSerie<S, D>[]\n) => {\n    const otherAxis = getOtherAxis(axis)\n    const all: number[] = []\n\n    xy[otherAxis].all.forEach(v => {\n        const compare = (isDate(v) ? compareDateValues : compareValues) as Compare\n        const stack: Array<number | null> = []\n\n        series.forEach(serie => {\n            const datum = serie.data.find(d => compare(d.data[otherAxis], v))\n            let value = null\n            let stackValue = null\n\n            if (datum !== undefined) {\n                // stacked values only support numbers\n                value = datum.data[axis] as number\n                if (value !== null) {\n                    const head = last(stack)\n                    if (head === undefined) {\n                        stackValue = value\n                    } else if (head !== null) {\n                        stackValue = head + value\n                    }\n                }\n\n                datum.data[axis === 'x' ? 'xStacked' : 'yStacked'] = stackValue\n            }\n\n            stack.push(stackValue)\n\n            if (stackValue !== null) {\n                all.push(stackValue)\n            }\n        })\n    })\n\n    xy[axis].minStacked = Math.min(...all)\n    xy[axis].maxStacked = Math.max(...all)\n}\n\nconst stackX = <S = never, D extends SerieDatum = SerieDatum>(\n    xy: StackedXY,\n    series: NestedSerie<S, D>[]\n) => stackAxis<S, D>('x', xy, series)\n\nconst stackY = <S = never, D extends SerieDatum = SerieDatum>(\n    xy: StackedXY,\n    series: NestedSerie<S, D>[]\n) => stackAxis<S, D>('y', xy, series)\n","export default function _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}","export default function _iterableToArrayLimit(arr, i) {\n  if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}","export default function _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}","import arrayWithHoles from \"@babel/runtime/helpers/esm/arrayWithHoles\";\nimport iterableToArrayLimit from \"@babel/runtime/helpers/esm/iterableToArrayLimit\";\nimport unsupportedIterableToArray from \"@babel/runtime/helpers/esm/unsupportedIterableToArray\";\nimport nonIterableRest from \"@babel/runtime/helpers/esm/nonIterableRest\";\nexport default function _slicedToArray(arr, i) {\n  return arrayWithHoles(arr) || iterableToArrayLimit(arr, i) || unsupportedIterableToArray(arr, i) || nonIterableRest();\n}","import {\n    CountableTimeInterval,\n    timeMillisecond,\n    utcMillisecond,\n    timeSecond,\n    utcSecond,\n    timeMinute,\n    utcMinute,\n    timeHour,\n    utcHour,\n    timeWeek,\n    utcWeek,\n    timeSunday,\n    utcSunday,\n    timeMonday,\n    utcMonday,\n    timeTuesday,\n    utcTuesday,\n    timeWednesday,\n    utcWednesday,\n    timeThursday,\n    utcThursday,\n    timeFriday,\n    utcFriday,\n    timeSaturday,\n    utcSaturday,\n    timeMonth,\n    utcMonth,\n    timeYear,\n    utcYear,\n    timeInterval,\n} from 'd3-time'\nimport { ScaleValue, TicksSpec, AnyScale, ScaleWithBandwidth } from './types'\n\nexport const centerScale = <Value>(scale: ScaleWithBandwidth) => {\n    const bandwidth = scale.bandwidth()\n\n    if (bandwidth === 0) return scale\n\n    let offset = bandwidth / 2\n    if (scale.round()) {\n        offset = Math.round(offset)\n    }\n\n    return <T extends Value>(d: T) => (scale(d) ?? 0) + offset\n}\n\nconst timeDay = timeInterval(\n    date => date.setHours(0, 0, 0, 0),\n    (date, step) => date.setDate(date.getDate() + step),\n    (start, end) => (end.getTime() - start.getTime()) / 864e5,\n    date => Math.floor(date.getTime() / 864e5)\n)\n\nconst utcDay = timeInterval(\n    date => date.setUTCHours(0, 0, 0, 0),\n    (date, step) => date.setUTCDate(date.getUTCDate() + step),\n    (start, end) => (end.getTime() - start.getTime()) / 864e5,\n    date => Math.floor(date.getTime() / 864e5)\n)\n\nconst timeByType: Record<string, [CountableTimeInterval, CountableTimeInterval]> = {\n    millisecond: [timeMillisecond, utcMillisecond],\n    second: [timeSecond, utcSecond],\n    minute: [timeMinute, utcMinute],\n    hour: [timeHour, utcHour],\n    day: [timeDay, utcDay],\n    week: [timeWeek, utcWeek],\n    sunday: [timeSunday, utcSunday],\n    monday: [timeMonday, utcMonday],\n    tuesday: [timeTuesday, utcTuesday],\n    wednesday: [timeWednesday, utcWednesday],\n    thursday: [timeThursday, utcThursday],\n    friday: [timeFriday, utcFriday],\n    saturday: [timeSaturday, utcSaturday],\n    month: [timeMonth, utcMonth],\n    year: [timeYear, utcYear],\n}\n\nconst timeTypes = Object.keys(timeByType)\nconst timeIntervalRegexp = new RegExp(`^every\\\\s*(\\\\d+)?\\\\s*(${timeTypes.join('|')})s?$`, 'i')\n\nconst isInteger = (value: unknown): value is number =>\n    typeof value === 'number' && isFinite(value) && Math.floor(value) === value\n\nexport const getScaleTicks = <Value extends ScaleValue>(\n    scale: AnyScale,\n    spec?: TicksSpec<Value>\n) => {\n    // specific values\n    if (Array.isArray(spec)) {\n        return spec\n    }\n\n    if (typeof spec === 'string' && 'useUTC' in scale) {\n        // time interval\n        const matches = spec.match(timeIntervalRegexp)\n\n        if (matches) {\n            const [, amount, type] = matches\n            // UTC is used as it's more predictable\n            // however local time could be used too\n            // let's see how it fits users' requirements\n            const timeType = timeByType[type][scale.useUTC ? 1 : 0]\n\n            if (type === 'day') {\n                const [start, originalStop] = scale.domain()\n                const stop = new Date(originalStop)\n\n                // Set range to include last day in the domain since `interval.range` function is exclusive stop\n                stop.setDate(stop.getDate() + 1)\n\n                return timeType.every(Number(amount ?? 1))?.range(start, stop) ?? []\n            }\n\n            if (amount === undefined) {\n                return scale.ticks(timeType)\n            }\n\n            const interval = timeType.every(Number(amount))\n\n            if (interval) {\n                return scale.ticks(interval)\n            }\n        }\n\n        throw new Error(`Invalid tickValues: ${spec}`)\n    }\n\n    // continuous scales\n    if ('ticks' in scale) {\n        // default behaviour\n        if (spec === undefined) {\n            return scale.ticks()\n        }\n\n        // specific tick count\n        if (isInteger(spec)) {\n            return scale.ticks(spec)\n        }\n    }\n\n    // non linear scale default\n    return scale.domain()\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}