import { useCallback, createElement, useState, useMemo, Fragment as Fragment$1 } from 'react';
import { useMotionConfig, useAnimatedPath, useCurveInterpolation, stackOffsetFromProp, stackOrderFromProp, useTheme, usePropertyAccessor, useValueFormatter, Container, useDimensions, bindDefs, SvgWrapper, ResponsiveWrapper } from '@nivo/core';
import { Grid, Axes } from '@nivo/axes';
import { BoxLegendSvg } from '@nivo/legends';
import { useSpring, animated } from '@react-spring/web';
import { useTooltip, BasicTooltip, Chip, TableTooltip } from '@nivo/tooltip';
import { jsx, Fragment, jsxs } from 'react/jsx-runtime';
import { area, stack } from 'd3-shape';
import { scalePoint, scaleLinear } from 'd3-scale';
import { useOrdinalColorScale, useInheritedColor } from '@nivo/colors';

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }
  return target;
}

function _objectWithoutProperties(source, excluded) {
  if (source == null) return {};
  var target = _objectWithoutPropertiesLoose(source, excluded);
  var key, i;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }
  return target;
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    if (i % 2) {
      ownKeys(Object(source), true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}

var StreamLayer = function StreamLayer(_ref) {
  var layer = _ref.layer,
      fillOpacity = _ref.fillOpacity,
      borderWidth = _ref.borderWidth,
      getBorderColor = _ref.getBorderColor,
      isInteractive = _ref.isInteractive,
      tooltip = _ref.tooltip;

  var _useTooltip = useTooltip(),
      showTooltipFromEvent = _useTooltip.showTooltipFromEvent,
      hideTooltip = _useTooltip.hideTooltip;

  var handleMouseHover = useCallback(function (event) {
    showTooltipFromEvent(createElement(tooltip, {
      layer: layer
    }), event, 'left');
  }, [showTooltipFromEvent, layer]);

  var _useMotionConfig = useMotionConfig(),
      animate = _useMotionConfig.animate,
      springConfig = _useMotionConfig.config;

  var animatedPath = useAnimatedPath(layer.path);
  var animatedProps = useSpring({
    color: layer.color,
    config: springConfig,
    immediate: !animate
  });
  return jsx(animated.path, {
    d: animatedPath,
    fill: layer.fill ? layer.fill : animatedProps.color,
    fillOpacity: fillOpacity,
    stroke: getBorderColor(layer),
    strokeWidth: borderWidth,
    onMouseMove: isInteractive ? handleMouseHover : undefined,
    onMouseEnter: isInteractive ? handleMouseHover : undefined,
    onMouseLeave: isInteractive ? hideTooltip : undefined
  });
};

var StreamLayers = function StreamLayers(_ref) {
  var layers = _ref.layers,
      fillOpacity = _ref.fillOpacity,
      borderWidth = _ref.borderWidth,
      getBorderColor = _ref.getBorderColor,
      isInteractive = _ref.isInteractive,
      tooltip = _ref.tooltip;
  return jsx("g", {
    children: layers.map(function (layer, i) {
      return jsx(StreamLayer, {
        layer: layer,
        getBorderColor: getBorderColor,
        borderWidth: borderWidth,
        fillOpacity: fillOpacity,
        isInteractive: isInteractive,
        tooltip: tooltip
      }, i);
    })
  });
};

var getDotY = function getDotY(datum, position) {
  var y = datum.y2;

  if (position === 'center') {
    y = datum.y1 + (datum.y2 - datum.y1) / 2;
  } else if (position === 'start') {
    y = datum.y1;
  }

  return y;
};

var StreamDots = function StreamDots(_ref) {
  var data = _ref.data,
      dotComponent = _ref.dotComponent,
      position = _ref.position,
      getSize = _ref.getSize,
      getColor = _ref.getColor,
      getBorderWidth = _ref.getBorderWidth,
      getBorderColor = _ref.getBorderColor;
  return jsx(Fragment, {
    children: data.map(function (datum, i) {
      return createElement(dotComponent, {
        key: i,
        datum: datum,
        x: datum.x,
        y: getDotY(datum, position),
        size: getSize(datum),
        color: getColor(datum),
        borderWidth: getBorderWidth(datum),
        borderColor: getBorderColor(datum)
      });
    })
  });
};

function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

function _iterableToArrayLimit(arr, i) {
  if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = undefined;
  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);
      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }
  return _arr;
}

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}

function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
}

var StreamSlicesItem = function StreamSlicesItem(_ref) {
  var slice = _ref.slice,
      height = _ref.height,
      tooltip = _ref.tooltip;

  var _useState = useState(false),
      _useState2 = _slicedToArray(_useState, 2),
      isHover = _useState2[0],
      setIsHover = _useState2[1];

  var _useTooltip = useTooltip(),
      showTooltipFromEvent = _useTooltip.showTooltipFromEvent,
      hideTooltip = _useTooltip.hideTooltip;

  var handleMouseHover = useCallback(function (event) {
    setIsHover(true);
    showTooltipFromEvent(createElement(tooltip, {
      slice: slice
    }), event, 'left');
  }, [setIsHover, showTooltipFromEvent, tooltip, slice]);
  var handleMouseLeave = useCallback(function () {
    setIsHover(false);
    hideTooltip();
  }, [setIsHover, hideTooltip]);
  return jsxs("g", {
    transform: "translate(".concat(slice.x, ", 0)"),
    children: [isHover && jsx("line", {
      x1: 0,
      x2: 0,
      y1: 0,
      y2: height,
      stroke: "#000",
      strokeOpacity: 0.35,
      strokeWidth: 1
    }), jsx("rect", {
      x: -20,
      width: 40,
      height: height,
      fill: "#000",
      fillOpacity: 0,
      onMouseEnter: handleMouseHover,
      onMouseMove: handleMouseHover,
      onMouseLeave: handleMouseLeave
    })]
  });
};

var StreamSlices = function StreamSlices(_ref) {
  var slices = _ref.slices,
      height = _ref.height,
      tooltip = _ref.tooltip;
  return jsx("g", {
    children: slices.map(function (slice) {
      return jsx(StreamSlicesItem, {
        slice: slice,
        height: height,
        tooltip: tooltip
      }, slice.index);
    })
  });
};

var StreamDotsItem = function StreamDotsItem(_ref) {
  var x = _ref.x,
      y = _ref.y,
      size = _ref.size,
      color = _ref.color,
      borderWidth = _ref.borderWidth,
      borderColor = _ref.borderColor;

  var _useMotionConfig = useMotionConfig(),
      animate = _useMotionConfig.animate,
      springConfig = _useMotionConfig.config;

  var animatedProps = useSpring({
    x: x,
    y: y,
    radius: size * 0.5,
    color: color,
    config: springConfig,
    immediate: !animate
  });
  return jsx(animated.circle, {
    cx: animatedProps.x,
    cy: animatedProps.y,
    r: animatedProps.radius,
    fill: animatedProps.color,
    strokeWidth: borderWidth,
    stroke: borderColor
  });
};

var LayerTooltip = function LayerTooltip(_ref) {
  var layer = _ref.layer;
  return jsx(BasicTooltip, {
    id: layer.label,
    enableChip: true,
    color: layer.color
  });
};

var StackTooltip = function StackTooltip(_ref) {
  var slice = _ref.slice;
  var rows = useMemo(function () {
    return slice.stack.map(function (p) {
      return [jsx(Chip, {
        color: p.color
      }, p.layerId), p.layerLabel, p.formattedValue];
    });
  }, [slice]);
  return jsx(TableTooltip, {
    rows: rows
  });
};

var defaultProps = {
  label: 'id',
  order: 'none',
  offsetType: 'wiggle',
  curve: 'catmullRom',
  axisBottom: {},
  axisLeft: {},
  enableGridX: false,
  enableGridY: true,
  colors: {
    scheme: 'nivo'
  },
  fillOpacity: 1,
  borderWidth: 0,
  borderColor: {
    from: 'color',
    modifiers: [['darker', 1]]
  },
  enableDots: false,
  dotPosition: 'center',
  dotComponent: StreamDotsItem,
  dotSize: 6,
  dotColor: {
    from: 'color'
  },
  dotBorderWidth: 0,
  dotBorderColor: {
    from: 'color'
  },
  isInteractive: true,
  tooltip: LayerTooltip,
  enableStackTooltip: true,
  stackTooltip: StackTooltip,
  legends: [],
  legendLabel: 'id',
  role: 'application'
};
var svgDefaultProps = _objectSpread2(_objectSpread2({}, defaultProps), {}, {
  layers: ['grid', 'axes', 'layers', 'dots', 'slices', 'legends'],
  defs: [],
  fill: [],
  animate: true,
  motionConfig: 'default',
  role: 'img',
  isFocusable: false
});

var useStream = function useStream(_ref) {
  var width = _ref.width,
      height = _ref.height,
      data = _ref.data,
      keys = _ref.keys,
      _ref$label = _ref.label,
      label = _ref$label === void 0 ? defaultProps.label : _ref$label,
      valueFormat = _ref.valueFormat,
      _ref$offsetType = _ref.offsetType,
      offsetType = _ref$offsetType === void 0 ? defaultProps.offsetType : _ref$offsetType,
      _ref$order = _ref.order,
      order = _ref$order === void 0 ? defaultProps.order : _ref$order,
      _ref$curve = _ref.curve,
      curve = _ref$curve === void 0 ? defaultProps.curve : _ref$curve,
      _ref$colors = _ref.colors,
      colors = _ref$colors === void 0 ? defaultProps.colors : _ref$colors,
      _ref$borderColor = _ref.borderColor,
      borderColor = _ref$borderColor === void 0 ? defaultProps.borderColor : _ref$borderColor,
      _ref$dotSize = _ref.dotSize,
      dotSize = _ref$dotSize === void 0 ? defaultProps.dotSize : _ref$dotSize,
      _ref$dotColor = _ref.dotColor,
      dotColor = _ref$dotColor === void 0 ? defaultProps.dotColor : _ref$dotColor,
      _ref$dotBorderWidth = _ref.dotBorderWidth,
      dotBorderWidth = _ref$dotBorderWidth === void 0 ? defaultProps.dotBorderWidth : _ref$dotBorderWidth,
      _ref$dotBorderColor = _ref.dotBorderColor,
      dotBorderColor = _ref$dotBorderColor === void 0 ? defaultProps.dotBorderColor : _ref$dotBorderColor;
  var areaCurveFactory = useCurveInterpolation(curve);
  var areaGenerator = useMemo(function () {
    return area().x(function (_ref2) {
      var x = _ref2.x;
      return x;
    }).y0(function (_ref3) {
      var y1 = _ref3.y1;
      return y1;
    }).y1(function (_ref4) {
      var y2 = _ref4.y2;
      return y2;
    }).curve(areaCurveFactory);
  }, [areaCurveFactory]);
  var stack$1 = useMemo(function () {
    return stack().keys(keys).offset(stackOffsetFromProp(offsetType)).order(stackOrderFromProp(order));
  }, [keys, offsetType, order]);

  var _useMemo = useMemo(function () {
    var allMin = [];
    var allMax = [];
    var layers = stack$1(data).map(function (layer) {
      return layer.map(function (point) {
        allMin.push(point[0]);
        allMax.push(point[1]);
        return _objectSpread2(_objectSpread2({}, point), {}, {
          value: point.data[layer.key]
        });
      });
    });
    var minValue = Math.min.apply(Math, allMin);
    var maxValue = Math.max.apply(Math, allMax);
    return [layers, scalePoint().domain(Array.from({
      length: data.length
    }, function (_, i) {
      return i;
    })).range([0, width]), scaleLinear().domain([minValue, maxValue]).range([height, 0])];
  }, [stack$1, data, width, height]),
      _useMemo2 = _slicedToArray(_useMemo, 3),
      layers = _useMemo2[0],
      xScale = _useMemo2[1],
      yScale = _useMemo2[2];

  var theme = useTheme();
  var getColor = useOrdinalColorScale(colors, 'id');
  var getBorderColor = useInheritedColor(borderColor, theme);
  var getDotSize = useMemo(function () {
    return typeof dotSize === 'function' ? dotSize : function () {
      return dotSize;
    };
  }, [dotSize]);
  var getDotColor = useInheritedColor(dotColor, theme);
  var getDotBorderWidth = useMemo(function () {
    return typeof dotBorderWidth === 'function' ? dotBorderWidth : function () {
      return dotBorderWidth;
    };
  }, [dotBorderWidth]);
  var getDotBorderColor = useInheritedColor(dotBorderColor, theme);
  var getLabel = usePropertyAccessor(label);
  var formatValue = useValueFormatter(valueFormat);
  var enhancedLayers = useMemo(function () {
    return layers.map(function (points, layerIndex) {
      var computedPoints = points.map(function (point, i) {
        return {
          layerId: keys[layerIndex],
          layerLabel: '',
          index: i,
          color: '',
          x: xScale(i),
          value: point.value,
          formattedValue: formatValue(point.value),
          y1: yScale(point[0]),
          y2: yScale(point[1])
        };
      });
      var layer = {
        id: keys[layerIndex],
        path: areaGenerator(computedPoints)
      };

      var layerWithComputedProperties = _objectSpread2(_objectSpread2({}, layer), {}, {
        label: getLabel(layer),
        color: getColor(layer)
      });

      return _objectSpread2(_objectSpread2({}, layerWithComputedProperties), {}, {
        data: computedPoints.map(function (point) {
          point.layerLabel = layerWithComputedProperties.label;
          point.color = layerWithComputedProperties.color;
          return point;
        })
      });
    });
  }, [layers, keys, getLabel, areaGenerator, getColor, xScale, yScale, formatValue]);
  var slices = useMemo(function () {
    return Array.from({
      length: data.length
    }, function (_, i) {
      var sliceStack = enhancedLayers.map(function (layer) {
        return layer.data[i];
      }).sort(function (a, b) {
        return a.y2 - b.y2;
      });
      return {
        index: i,
        x: enhancedLayers[0].data[i].x,
        stack: sliceStack
      };
    });
  }, [data.length, enhancedLayers]);
  var layerContext = useMemo(function () {
    return {
      xScale: xScale,
      yScale: yScale,
      layers: enhancedLayers,
      slices: slices
    };
  }, [xScale, yScale, enhancedLayers, slices]);
  return {
    xScale: xScale,
    yScale: yScale,
    layers: enhancedLayers,
    slices: slices,
    getBorderColor: getBorderColor,
    getDotSize: getDotSize,
    getDotColor: getDotColor,
    getDotBorderWidth: getDotBorderWidth,
    getDotBorderColor: getDotBorderColor,
    layerContext: layerContext
  };
};

var InnerStream = function InnerStream(_ref) {
  var data = _ref.data,
      keys = _ref.keys,
      label = _ref.label,
      valueFormat = _ref.valueFormat,
      offsetType = _ref.offsetType,
      order = _ref.order,
      curve = _ref.curve,
      _ref$layers = _ref.layers,
      chartLayers = _ref$layers === void 0 ? svgDefaultProps.layers : _ref$layers,
      width = _ref.width,
      height = _ref.height,
      partialMargin = _ref.margin,
      axisTop = _ref.axisTop,
      axisRight = _ref.axisRight,
      _ref$axisBottom = _ref.axisBottom,
      axisBottom = _ref$axisBottom === void 0 ? svgDefaultProps.axisBottom : _ref$axisBottom,
      _ref$axisLeft = _ref.axisLeft,
      axisLeft = _ref$axisLeft === void 0 ? svgDefaultProps.axisLeft : _ref$axisLeft,
      _ref$enableGridX = _ref.enableGridX,
      enableGridX = _ref$enableGridX === void 0 ? svgDefaultProps.enableGridX : _ref$enableGridX,
      _ref$enableGridY = _ref.enableGridY,
      enableGridY = _ref$enableGridY === void 0 ? svgDefaultProps.enableGridY : _ref$enableGridY,
      colors = _ref.colors,
      _ref$fillOpacity = _ref.fillOpacity,
      fillOpacity = _ref$fillOpacity === void 0 ? svgDefaultProps.fillOpacity : _ref$fillOpacity,
      _ref$borderWidth = _ref.borderWidth,
      borderWidth = _ref$borderWidth === void 0 ? svgDefaultProps.borderWidth : _ref$borderWidth,
      borderColor = _ref.borderColor,
      _ref$defs = _ref.defs,
      defs = _ref$defs === void 0 ? svgDefaultProps.defs : _ref$defs,
      _ref$fill = _ref.fill,
      fill = _ref$fill === void 0 ? svgDefaultProps.fill : _ref$fill,
      _ref$enableDots = _ref.enableDots,
      enableDots = _ref$enableDots === void 0 ? svgDefaultProps.enableDots : _ref$enableDots,
      _ref$dotPosition = _ref.dotPosition,
      dotPosition = _ref$dotPosition === void 0 ? svgDefaultProps.dotPosition : _ref$dotPosition,
      _ref$dotComponent = _ref.dotComponent,
      dotComponent = _ref$dotComponent === void 0 ? svgDefaultProps.dotComponent : _ref$dotComponent,
      dotSize = _ref.dotSize,
      dotColor = _ref.dotColor,
      dotBorderWidth = _ref.dotBorderWidth,
      dotBorderColor = _ref.dotBorderColor,
      _ref$isInteractive = _ref.isInteractive,
      isInteractive = _ref$isInteractive === void 0 ? svgDefaultProps.isInteractive : _ref$isInteractive,
      _ref$tooltip = _ref.tooltip,
      tooltip = _ref$tooltip === void 0 ? svgDefaultProps.tooltip : _ref$tooltip,
      _ref$enableStackToolt = _ref.enableStackTooltip,
      enableStackTooltip = _ref$enableStackToolt === void 0 ? svgDefaultProps.enableStackTooltip : _ref$enableStackToolt,
      _ref$stackTooltip = _ref.stackTooltip,
      stackTooltip = _ref$stackTooltip === void 0 ? svgDefaultProps.stackTooltip : _ref$stackTooltip,
      _ref$legends = _ref.legends,
      legends = _ref$legends === void 0 ? svgDefaultProps.legends : _ref$legends,
      role = _ref.role,
      ariaLabel = _ref.ariaLabel,
      ariaLabelledBy = _ref.ariaLabelledBy,
      ariaDescribedBy = _ref.ariaDescribedBy;

  var _useDimensions = useDimensions(width, height, partialMargin),
      margin = _useDimensions.margin,
      innerWidth = _useDimensions.innerWidth,
      innerHeight = _useDimensions.innerHeight,
      outerWidth = _useDimensions.outerWidth,
      outerHeight = _useDimensions.outerHeight;

  var _useStream = useStream({
    width: innerWidth,
    height: innerHeight,
    data: data,
    keys: keys,
    label: label,
    valueFormat: valueFormat,
    offsetType: offsetType,
    order: order,
    curve: curve,
    colors: colors,
    borderColor: borderColor,
    dotSize: dotSize,
    dotColor: dotColor,
    dotBorderWidth: dotBorderWidth,
    dotBorderColor: dotBorderColor
  }),
      xScale = _useStream.xScale,
      yScale = _useStream.yScale,
      layers = _useStream.layers,
      slices = _useStream.slices,
      getBorderColor = _useStream.getBorderColor,
      getDotSize = _useStream.getDotSize,
      getDotColor = _useStream.getDotColor,
      getDotBorderWidth = _useStream.getDotBorderWidth,
      getDotBorderColor = _useStream.getDotBorderColor,
      layerContext = _useStream.layerContext;

  var boundDefs = bindDefs(defs, layers, fill);
  var layerById = {
    grid: null,
    axes: null,
    layers: null,
    dots: null,
    slices: null,
    legends: null
  };

  if (chartLayers.includes('grid')) {
    layerById.grid = jsx(Grid, {
      width: innerWidth,
      height: innerHeight,
      xScale: enableGridX ? xScale : null,
      yScale: enableGridY ? yScale : null
    }, "grid");
  }

  if (chartLayers.includes('axes')) {
    layerById.axes = jsx(Axes, {
      xScale: xScale,
      yScale: yScale,
      width: innerWidth,
      height: innerHeight,
      top: axisTop,
      right: axisRight,
      bottom: axisBottom,
      left: axisLeft
    }, "axes");
  }

  if (chartLayers.includes('layers')) {
    layerById.layers = jsx(StreamLayers, {
      layers: layers,
      fillOpacity: fillOpacity,
      borderWidth: borderWidth,
      getBorderColor: getBorderColor,
      isInteractive: isInteractive,
      tooltip: tooltip
    }, "layers");
  }

  if (chartLayers.includes('dots') && enableDots) {
    layerById.dots = jsx(Fragment$1, {
      children: layers.map(function (layer) {
        return jsx(StreamDots, {
          id: layer.id,
          color: layer.color,
          data: layer.data,
          dotComponent: dotComponent,
          position: dotPosition,
          getSize: getDotSize,
          getColor: getDotColor,
          getBorderWidth: getDotBorderWidth,
          getBorderColor: getDotBorderColor
        }, layer.id);
      })
    }, "dots");
  }

  if (chartLayers.includes('slices') && isInteractive && enableStackTooltip) {
    layerById.slices = jsx(StreamSlices, {
      slices: slices,
      height: innerHeight,
      tooltip: stackTooltip
    }, "slices");
  }

  if (chartLayers.includes('legends')) {
    layerById.legends = jsx(Fragment$1, {
      children: legends.map(function (legend, i) {
        var legendData = layers.map(function (layer) {
          return {
            id: layer.id,
            label: layer.label,
            color: layer.color,
            fill: layer.fill
          };
        }).reverse();
        return jsx(BoxLegendSvg, _objectSpread2(_objectSpread2({}, legend), {}, {
          containerWidth: innerWidth,
          containerHeight: innerHeight,
          data: legendData
        }), i);
      })
    }, "legends");
  }

  return jsx(SvgWrapper, {
    width: outerWidth,
    height: outerHeight,
    margin: margin,
    defs: boundDefs,
    role: role,
    ariaLabel: ariaLabel,
    ariaLabelledBy: ariaLabelledBy,
    ariaDescribedBy: ariaDescribedBy,
    children: chartLayers.map(function (layer, i) {
      var _layerById$layer;

      if (typeof layer === 'function') {
        return jsx(Fragment$1, {
          children: createElement(layer, layerContext)
        }, i);
      }

      return (_layerById$layer = layerById === null || layerById === void 0 ? void 0 : layerById[layer]) !== null && _layerById$layer !== void 0 ? _layerById$layer : null;
    })
  });
};

var Stream = function Stream(_ref2) {
  var _ref2$isInteractive = _ref2.isInteractive,
      isInteractive = _ref2$isInteractive === void 0 ? svgDefaultProps.isInteractive : _ref2$isInteractive,
      _ref2$animate = _ref2.animate,
      animate = _ref2$animate === void 0 ? svgDefaultProps.animate : _ref2$animate,
      _ref2$motionConfig = _ref2.motionConfig,
      motionConfig = _ref2$motionConfig === void 0 ? svgDefaultProps.motionConfig : _ref2$motionConfig,
      theme = _ref2.theme,
      renderWrapper = _ref2.renderWrapper,
      otherProps = _objectWithoutProperties(_ref2, ["isInteractive", "animate", "motionConfig", "theme", "renderWrapper"]);

  return jsx(Container, {
    animate: animate,
    isInteractive: isInteractive,
    motionConfig: motionConfig,
    renderWrapper: renderWrapper,
    theme: theme,
    children: jsx(InnerStream, _objectSpread2({
      isInteractive: isInteractive
    }, otherProps))
  });
};

var ResponsiveStream = function ResponsiveStream(props) {
  return jsx(ResponsiveWrapper, {
    children: function children(_ref) {
      var width = _ref.width,
          height = _ref.height;
      return jsx(Stream, _objectSpread2({
        width: width,
        height: height
      }, props));
    }
  });
};

export { ResponsiveStream, Stream, defaultProps, svgDefaultProps };
//# sourceMappingURL=nivo-stream.es.js.map
